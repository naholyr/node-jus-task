#!/usr/bin/env node

const helper = require('../lib/helper');
const tasksRepository = require('../index');
const path = require('path');

const VERSION = '1.0.0';
const APP = path.basename(__filename);

if (process.argv.indexOf('--help') != -1) {
  showHelp();
} else if (process.argv.indexOf('--version') != -1) {
  showVersion();
}

if (process.argv.indexOf('--no-color') != -1) {
  helper.noColor = true;
}

try {
  main();
} catch (err) {
  helper.logError(err);
  process.exit(1);
}

function main() {
  // Browse arguments to extract task
  var task = null;
  for (var i=2; i<process.argv.length; i++) {
    if (!process.argv[i].match(/^-/)) {
      task = tasksRepository.find(process.argv[i]);
      break;
    }
  }
  if (!task) { // No argument for a task, or we would have found a task OR thrown an exception
    showHelp();
  }
  // Parse argv and execute task
  var opts = {}, args = [];
  (function() {
    var optionExpectingValue = null, skippedFirstArgument = false;
    for (var i=2; i<process.argv.length; i++) {
      var opt = process.argv[i];
      if (opt.match(/^-/)) { // Short or long option
        if (optionExpectingValue !== null) {
          throw new Error('Error at "' + opt + '", previous option "' + optionExpectingValue + '" was expecting an argument');
        }
        var optName = opt.substring(1), optVal = undefined;
        if (opt.match(/^--/)) { // Long option
          optName = opt.substring(2);
          var eqPos = opt.indexOf('=');
          if (eqPos != -1) {
            optName = opt.substring(2, eqPos);
            optVal = parseOptValue(opt.substring(eqPos+1));
          }
        } else { // Short option
          if (optName.length > 1) {
            optName = optName.substring(0, 1);
            optVal = parseOptValue(optName.substring(1));
          }
        }
        var option = task.getOption(optName);
        if (!option) {
          throw new Error('Unexpected "' + opt + '"');
        }
        if (option.expectsValue && optVal === undefined) {
          optionExpectingValue = optName;
        }
        opts[optName] = optVal;
      } else { // Argument
        if (optionExpectingValue !== null) {
          opts[optionExpectingValue] = parseOptValue(opt);
          optionExpectingValue = null;
        } else {
          if (!skippedFirstArgument) { // Skip first argument, as it's the task name
            skippedFirstArgument = true;
          } else {
            args.push(parseOptValue(opt));
          }
        }
      }
    }
  })();
  task.execute(opts, args);
}

function parseOptValue(v) {
  if (v == 'false') return false;
  if (v == 'null')  return null;
  if (v == 'true')  return true;
  return v;
}

function showHelp() {
  var help = ''
    + helper.colorize('Usage:', 'yellow') + '\n'
    + '  ' + APP + ' [OPTIONS] [Task] [ARGUMENTS]\n'
    + '\n'
    + helper.colorize('Options:', 'yellow') + '\n'
    + helper.getOptionsHelp([
        ['--help', null, 'Show this help and exit'],
        ['--version', null, 'Show version and exit'],
        ['--no-color', null, 'Disable ANSI color']
      ])
    + '\n'
    + helper.colorize('Available tasks:', 'yellow') + '\n'
    + '  Call "' + APP + ' list"\n';
  console.log(help);
  process.exit(0);
}

function showVersion() {
  helper.log(VERSION);
  process.exit(0);
}
